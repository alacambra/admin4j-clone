/*
 * This software is licensed under the Apache License, Version 2.0
 * (the "License") agreement; you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.admin4j.jdbc.driver.sql;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

import net.admin4j.jdbc.driver.SqlStatementTimerFactory;
import net.admin4j.timer.TaskTimer;
import net.admin4j.util.annotate.PackageRestrictions;

/**
 * Wraps a JDBC V2.0 statement so specifics can be reported to administrators.
 * @author D. Ashmore
 * @since 1.0
 */
@PackageRestrictions({"net.admin4j","java","javax"})
public abstract class StatementWrapper30Base implements Statement {
    
    private ConnectionWrapper30Base connectionWrapper;
    private Statement statement;
    private StackTraceElement[] creationStackTrace;
    private boolean closed = false;
    
    public StatementWrapper30Base(ConnectionWrapper30Base connection, Statement statement) {
        SQLWrappingUtils.notNull(statement, "Null statement not allowed.");
        SQLWrappingUtils.notNull(connection, "Null connection wrapper not allowed.");
        this.statement = statement;
        this.connectionWrapper = connection;
    }
    
    protected Statement getUnderlyingStatement() {
        return this.statement;
    }

    public void addBatch(String sql) throws SQLException {
        this.statement.addBatch(sql);

    }

    public void cancel() throws SQLException {
        this.statement.cancel();

    }

    public void clearBatch() throws SQLException {
        this.statement.clearBatch();

    }

    public void clearWarnings() throws SQLException {
        this.statement.clearWarnings();

    }

    public void close() throws SQLException {
        this.statement.close();
        closed = true;
    }

    public boolean execute(String sql) throws SQLException {

        TaskTimer timer = null;
        try {
            timer = SqlStatementTimerFactory.start(sql, 
                    this.getConnectionWrapper().getDriverContext(),
                    this.getConnectionWrapper().registerSqlStatement(sql));
            return this.statement.execute(sql);
        }
        finally {
            if (timer != null) timer.stop();
        }
    }

    public boolean execute(String sql, int autoGeneratedKeys)
            throws SQLException {
        
        TaskTimer timer = null;
        try {
            timer = SqlStatementTimerFactory.start(sql, 
                    this.getConnectionWrapper().getDriverContext(),
                    this.getConnectionWrapper().registerSqlStatement(sql));
            return this.statement.execute(sql, autoGeneratedKeys);
        }
        finally {
            if (timer != null) timer.stop();
        }
    }

    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
       
        TaskTimer timer = null;
        try {
            timer = SqlStatementTimerFactory.start(sql, 
                    this.getConnectionWrapper().getDriverContext(),
                    this.getConnectionWrapper().registerSqlStatement(sql));
            return this.statement.execute(sql, columnIndexes);
        }
        finally {
            if (timer != null) timer.stop();
        }
    }

    public boolean execute(String sql, String[] columnNames)
            throws SQLException {
       
        TaskTimer timer = null;
        try {
            timer = SqlStatementTimerFactory.start(sql, 
                    this.getConnectionWrapper().getDriverContext(),
                    this.getConnectionWrapper().registerSqlStatement(sql));
            return this.statement.execute(sql, columnNames);
        }
        finally {
            if (timer != null) timer.stop();
        }
    }

    public int[] executeBatch() throws SQLException {
        return this.statement.executeBatch();
    }

    public ResultSet executeQuery(String sql) throws SQLException {
       
        TaskTimer timer = null;
        try {
            timer = SqlStatementTimerFactory.start(sql, 
                    this.getConnectionWrapper().getDriverContext(),
                    this.getConnectionWrapper().registerSqlStatement(sql));
            return this.statement.executeQuery(sql);
        }
        finally {
            if (timer != null) timer.stop();
        }
    }

    public int executeUpdate(String sql) throws SQLException {
        
        TaskTimer timer = null;
        try {
            timer = SqlStatementTimerFactory.start(sql, 
                    this.getConnectionWrapper().getDriverContext(),
                    this.getConnectionWrapper().registerSqlStatement(sql));
            return this.statement.executeUpdate(sql);
        }
        finally {
            if (timer != null) timer.stop();
        }
    }

    public int executeUpdate(String sql, int autoGeneratedKeys)
            throws SQLException {
      
        TaskTimer timer = null;
        try {
            timer = SqlStatementTimerFactory.start(sql, 
                    this.getConnectionWrapper().getDriverContext(),
                    this.getConnectionWrapper().registerSqlStatement(sql));
            return this.statement.executeUpdate(sql, autoGeneratedKeys);
        }
        finally {
            if (timer != null) timer.stop();
        }
    }

    public int executeUpdate(String sql, int[] columnIndexes)
            throws SQLException {

        TaskTimer timer = null;
        try {
            timer = SqlStatementTimerFactory.start(sql, 
                    this.getConnectionWrapper().getDriverContext(),
                    this.getConnectionWrapper().registerSqlStatement(sql));
            return this.statement.executeUpdate(sql, columnIndexes);
        }
        finally {
            if (timer != null) timer.stop();
        }
    }

    public int executeUpdate(String sql, String[] columnNames)
            throws SQLException {
       
        TaskTimer timer = null;
        try {
            timer = SqlStatementTimerFactory.start(sql, 
                    this.getConnectionWrapper().getDriverContext(),
                    this.getConnectionWrapper().registerSqlStatement(sql));
            return this.statement.executeUpdate(sql, columnNames);
        }
        finally {
            if (timer != null) timer.stop();
        }
    }

    public Connection getConnection() throws SQLException {
        return this.connectionWrapper;
    }

    public int getFetchDirection() throws SQLException {
        return this.statement.getFetchDirection();
    }

    public int getFetchSize() throws SQLException {
        return this.statement.getFetchSize();
    }

    public ResultSet getGeneratedKeys() throws SQLException {
        return this.statement.getGeneratedKeys();
    }

    public int getMaxFieldSize() throws SQLException {
        return this.statement.getMaxFieldSize();
    }

    public int getMaxRows() throws SQLException {
        return this.statement.getMaxRows();
    }

    public boolean getMoreResults() throws SQLException {
        return this.statement.getMoreResults();
    }

    public boolean getMoreResults(int current) throws SQLException {
        return this.statement.getMoreResults(current);
    }

    public int getQueryTimeout() throws SQLException {
        return this.statement.getQueryTimeout();
    }

    public ResultSet getResultSet() throws SQLException {
        return this.statement.getResultSet();
    }

    public int getResultSetConcurrency() throws SQLException {
        return this.statement.getResultSetConcurrency();
    }

    public int getResultSetHoldability() throws SQLException {
        return this.statement.getResultSetHoldability();
    }

    public int getResultSetType() throws SQLException {
        return this.statement.getResultSetType();
    }

    public int getUpdateCount() throws SQLException {
        return this.statement.getUpdateCount();
    }

    public SQLWarning getWarnings() throws SQLException {
        return this.statement.getWarnings();
    }

    public void setCursorName(String name) throws SQLException {
        this.statement.setCursorName(name);

    }

    public void setEscapeProcessing(boolean enable) throws SQLException {
        this.statement.setEscapeProcessing(enable);

    }

    public void setFetchDirection(int direction) throws SQLException {
        this.statement.setFetchDirection(direction);

    }

    public void setFetchSize(int rows) throws SQLException {
        this.statement.setFetchSize(rows);

    }

    public void setMaxFieldSize(int max) throws SQLException {
        this.statement.setMaxFieldSize(max);

    }

    public void setMaxRows(int max) throws SQLException {
        this.statement.setMaxRows(max);

    }

    public void setQueryTimeout(int seconds) throws SQLException {
        this.statement.setQueryTimeout(seconds);

    }

    protected void finalize() throws Throwable {
        if (!this.closed) { // Can't use isClosed() and still use the same class under jdk 1.5
            DriverManager.getLogWriter().println("Leaked database statement closed.");
            this.close();
        }
        super.finalize();
    }
    
    public StackTraceElement[] getCreationStackTrace() {
        return creationStackTrace;
    }

    protected ConnectionWrapper30Base getConnectionWrapper() {
        return connectionWrapper;
    }
    
}
